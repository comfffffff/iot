# iot

## 1-1

변수를 선언하면 변수 영역에 식별자로 지정되는 빈 공간이 확보된다

## 1-2

데이터 영역에 할당된 데이터는 변수 영역의 값이 가리키는 주소에 저장된다

## 1-3

숫자, 문자열, boolean, null, undefined, Symbol은 불변값으로 한번 만들어진 값은 변하지 않는다

## 1-4

데이터 영역에 저장된 참조형 데이터는 그 데이터가 가리키는 변수가 변함에 따라 그 값도 변하는 가변값이다

## 1-5

참조형 데이터의 프로퍼티를 재할당할 경우 해당 객체의 변수 영역이 가리키는 데이터 영역이 달라지므로 변수 영역의 값이 바뀐다

## 1-6

객체의 프로퍼티로서 객체가 있는 경우 중첩된 참조가 일어난다

## 1-7

변수의 복사가 일어나는 경우 복사가 일어난 두 변수는 같은 데이터 영역을 가리킨다

## 1-8

복사된 객체의 프로퍼티를 변경하더라도 변수가 가리키는 데이터 영역은 원본 객체와 같다 

## 1-9

복사된 객체 자체를 변경하면 원본 객체와 별개의 데이터 영역을 가리키게 된다

## 1-10

복사된 객체의 프로퍼티만을 수정하여, 원본 객체와 사본 객체가 가리키는 데이터 영역이 같아짐에 따라

원본 객체의 프로퍼티가 달라지는 문제가 발생한다

## 1-11

객체를 통째로 다시 만들어 변수에 저장함으로써 문제를 해결했다

## 1-12

객체의 얕은 복사를 수행한다

## 1-13

1-12에서 만든 객체 복사 함수를 이용해 복사하고, 객체의 불변성을 유지했다

## 1-14

중첩된 객체에 대해 얕은 복사를 수행하면 객체 프로퍼티에 대해 원본의 불변성이 확보되지 않는다

## 1-15

객체의 깊은 복사는 객체 프로퍼티의 내부까지 복사해 원본 객체의 불변성을 유지했다

## 1-16

객체 프로퍼티에 대해 copyObjectDeep 함수를 재귀적으로 호출해 깊은 복사를 범용적으로 실시한다

## 1-17

1-16의 깊은 복사의 결과를 확인한다

## 1-18

객체를 JSON 문법으로 치환해 깊은 복사를 수행한 뒤 다시 객체로 치환한다. 

이때 함수는 JSON 문법으로 변경할 수 없어 복사 과정에서 무시되었다

## 1-19

undefined가 자동으로 부여되는 경우는 다음 세가지 경우이다

1. 값을 대입하지 않은 변수에 접근하는 경우
2. 존재하지 않는 프로퍼티에 접근하는 경우
3. 함수의 반환값이 존재하지 않는 경우

## 1-20

배열에서는, undefined가 할당된 요소와 비어있는 요소는 다른 개념이다

## 1-21

비어있는 요소는 배열 메서드의 순회 대상에서 제외된다

## 1-22

typeof null이 object를 반환하는 버그가 있다. 따라서 어떤 변수가 null인지 판별하기 위해선 일치 연산자를 사용해야 한다.

## 2-1

함수를 이용해 실행 컨텍스트를 구성해보면서 콜 스택에 실행 컨텍스트가 쌓이는 순서를 확인해본다.

## 2-2

호이스팅의 개념을 출력을 통해 확인한다

## 2-3

매개변수를 변수 선언 및 할당과 동일하다고 간주하여 변환한 코드를 출력한다

## 2-4

호이스팅을 마친 상태로 간주해 변환한 코드이다

## 2-5

함수 선언에 대한 호이스팅을 추가해 그 개념을 확인한다

## 2-6

호이스팅을 마친 상태로 간주해 이를 변환한 코드를 출력한다

## 2-7

함수 선언문을 함수 표현식으로 바꾼 코드의 결과를 출력한다

## 2-8

함수 선언문, 익명 함수 표현식, 기명 함수 표현식으로 선언된 세가지 방식을 확인한다. 기명 함수는 외부에서 접근이 불가해 오류가 발생한다

## 2-9

원본 코드의 출력을 통해 함수 선언문과 함수 표현식의 차이를 확인할 수 있다

## 2-10

호이스팅을 마친 상태로 간주해 이를 변환한 코드를 출력한다

## 2-11

같은 이름의 함수가 함수 선언문으로 추가되었을 때 실제로 호출되는 함수는 마지막에 할당한 함수이다 함수 선언문으로 정의한다면 오작동이 발생할 수 있다

## 2-12

함수 표현식으로 선언한다면 전역공간에 같은 이름의 함수가 있어도 에러 메세지를 출력해 오류를 확인할 수 있다

## 2-13

식별자 a에 접근하려고하지만, 활성화된 inner 컨텍스트의 environmentRecord 에서의 a는 undefined 상태이기에 undefined가 출력되고, 전역 lexicalEnvironment의 a값인 1과 전역 컨텍스트의 environmentRecord의 a값인 1이 출력된다

## 2-14

개발자 도구 콘솔을 이용해 크롬 브라우저에서 스코프를 확인할 수 있다

## 2-15

inner 함수 내부에서 b 변수를 호출하면 스코프에 b도 노출이 된다

## 2-16

크롬 브라우저에서 debugger로 바꾸면 스코프 체인과 this 정보를 확인할 수 있다.